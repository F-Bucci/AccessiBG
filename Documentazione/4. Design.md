## Organizzazione della documentazione



### Modelling (Lucidi nel Moodle)



DEVE contenere i diagrammi UML visti a lezione, se non già presentati in altre sezioni della

documentazione:

- use case diagram (si consiglia di metterlo nella sezione dei requisiti);

- class diagram (dal quale si DEVE generare una prima versione del codice in Java usando Papyrus Designer - si consiglia di metterlo nella sezione software design);

- ALMENO UNO state machine diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono uno state diagram come visto a lezione);

- ALMENO UN sequence diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono un sequence diagram come visto a lezione);

- UN diagramma TRA communication diagram e timing diagram;

- ALMENO UN activity diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono un activity diagram come visto a lezione);

- component diagram (si consiglia di metterlo nella sezione in cui si presenta la software architecture);

- package diagram (si consiglia di metterlo nella sezione in cui si presenta la software architecture o insieme al class diagram).



### Software Architecture (Cap.11)



* DEVE contenere la descrizione dell’architettura con almeno un paio di architectural views (per differenti punti di vista);
* DOVREBBE avere almeno una vista con connettori e componenti con la descrizione dello stile architetturale (11.4);
* DEVE utilizzare almeno una libreria esterna con maven. Ad esempio l’uso di log4j è molto consigliata.



### Software Design pattern (Cap.12)



* DEVE contenere una descrizione del design (mediante i diagrammi UML va bene);
* POTREBBE contenere un calcolo di complessità (ad esempio con McCabe) di una piccola parte;
* DOVREBBE contenere qualche misurazione del codice, (con qualche metrica che abbiamo visto). Alcuni tools che vedremo a lezione: stanide, jdepend, struture101, sonarlint, PMD…
* DEVE applicare un paio di design pattern visti a lezione;
* *Documentazione*: Documentare l’architettura e il design in documento.



---

# Introduzione

In questa documentazione verranno mostrati dei diagrammi UML riguardanti al nostro progetto.

Inoltre, si discuterà riguardo a:
- L'architettura del software, assieme alle architectural views, vista con connettori e componenti e delle librerie utilizzate;
- Il design, assieme ad un calcolo di complessità, misurazione del codice (e con quali strumenti) e i design pattern applicati.

# Modelling

### Use Case Diagram

<img width="913" height="1278" alt="Use case Diagram" src="https://github.com/user-attachments/assets/146b7512-ffc9-40e6-82c8-524f94e400a3" />


### Class Diagram e Package Diagram

<img width="4540" height="1780" alt="AccessiBG_ClassDiagram" src="https://github.com/user-attachments/assets/e3c79e37-6fbb-4876-b3b5-9a4699f10174" />


### State Machine Diagram

<img width="3153" height="779" alt="image" src="https://github.com/user-attachments/assets/2ae5a335-0f06-438e-b974-ab5034200a76" />


### Sequence Diagram

<img width="538" height="1451" alt="image" src="https://github.com/user-attachments/assets/51017946-5e83-409d-b83b-3a115e014e71" />


### Communication Diagram

<img width="1253" height="395" alt="image" src="https://github.com/user-attachments/assets/9a959a9b-66cb-49ca-9e9f-91bb4af4f7a5" />


### Activity Diagram

<img width="2117" height="960" alt="Activity Diagram" src="https://github.com/user-attachments/assets/5203c95a-94d3-4f8e-b961-da120ea61af7" />


### Component Diagram

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/7cd8ceac-ff5d-4d21-bf15-0bbded94c32a" />






# Software Architecture

Struttura della webapp:
- **Maven**: gestione del progetto e strumento di automazione della compilazione, per i progetti Java. Utilizza POM (Project Object Model) per centralizzare e gestire in modo efficiente il processo di compilazione, la reportistica e la documentazione di un progetto;
- **Vaadin**: framework che permette di sviluppare una webapp (sia l'UI che il backend) con l'utilizzo di Java, senza l'uso di HTML e JavaScript. Inoltre, offre dei componenti già costruiti (ad esempio, griglie, form e bottoni);
- **SQLite**: motore di database embedded SQL, senza l'uso di server e senza configurazione. Legge e scrive direttamente su normali file su disco. Comunica con il progetto Maven.

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/b9991d6c-7e82-426e-ab0d-512c0dfd19bf" />



### Viste architettoniche

Ecco alcuni punti di vista architetturali:

#### - Punto di vista logico

Il sistema è progettato principalmente da questi elementi:

- Interfaccia della webapp;
- Backend della webapp;
- Database (SQLite e Jooq).

Per l'interazione tra gli elemento del sistema è possibile vedere nei diagrammi sottostanti:

<img width="4540" height="1780" alt="AccessiBG_ClassDiagram" src="https://github.com/user-attachments/assets/e3c79e37-6fbb-4876-b3b5-9a4699f10174" />

<img width="3153" height="779" alt="image" src="https://github.com/user-attachments/assets/2ae5a335-0f06-438e-b974-ab5034200a76" />

#### - Punto di vista dell'implementazione

Organizzazione delle classi basata su package, così per ciascun progetto.

I seguenti progetti sono strutturati in questa maniera con i package:

- Progetto Vaadin (accessibilita-unibg):
  - Applicazione per avviare la webapp + inizializzatore del DB (it.unibg.accessibilita);
  - Views (it.unibg.accessibilita.base.ui);
  - Componenti (it.unibg.accessibilita.ui.component).
 
- Progetto backend (AccessiBG_Backend):
  - Classi con design pattern DAO (dao);
  - Servizi offerti dalle università (servizi);
  - Parti della struttura universitaria (struttura).
 
- Progetto SQLite (AccessiBG_sqlite):
  - Classi per gestione DB (gestione_db).

<img width="4540" height="1780" alt="AccessiBG_ClassDiagram" src="https://github.com/user-attachments/assets/e3c79e37-6fbb-4876-b3b5-9a4699f10174" />

#### Architettura e componenti e connettori

Stile architetturale: layered client-server (a strati).
L'app è organizzata in tre livelli:
- Strato del frontend: modulo accessibilita-unibg con UI costruita usando Vaadin (componenti, routing e views);
- Strato del backend: modulo AccessiBG_Backend con servizi, logica di business e accesso ai repository;
- Strato dei dati: modulo AccessiBG_sqlite con utilità di inizializzazione del database SQLite (creazione tabelle e popolamento iniziale).

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/b50cb8b0-c879-4b81-a422-7a0cc4da63ae" />

Componenti:
- Vaadin UI (accessibilita-unibg): view e componenti per l’interazione utente; riceve i DAO tramite dependency injection e invoca i servizi/DAO in‑process.
- Servizi (AccessiBG_Backend): espongono i metodi di servizio utilizzate dalla UI;
- Gestione DB (AccessiBG_sqlite): creazione delle table e popolazione del database (CreateTable e InsertInDB), offre il servizio di creazione del DB (CreateDB).

Connettori:
Chiamate di metodo "in-process" ("in corso"): UI e backend vengono eseguiti nello stesso processo (Spring Boot + Vaadin). Le views ricevono i DAO/servizi tramite dependency injection e chiamano direttamente i loro metodi;
- JDBC (via sqlite-jdbc): jOOQ costruisce le query tramite DSLContext e le esegue utilizzando il driver JDBC org.xerial:sqlite-jdbc. Quindi la comunicazione con il DB SQLite avviene a livello JDBC.

Librerie esterne con Maven:
- Vaadin (com.vaadin:vaadin) per la realizzazione dell'interfaccia utente e dei componenti web con l'utilizzo di Java;
- sqlite-jdbc (org.xerial:sqlite-jdbc) per l'accesso al database SQLite in modalità embedded;
- jOOQ (org.jooq:jooq e jooq-codegen) per generazione e accesso tipo-safe alle query SQL, inoltre la generazione del codice del modello DB;


# Software Design pattern

\[INSERIRE DESCRIZIONE DEL DESIGN (MEDIANTE I DIAGRAMMI UML VA BENE)\]

\[SI POTREBBE INSERIRE UN CALCOLO DI COMPLESSITA' (COME AD ESEMPIO CON MCCABE) DI UNA PICCOLA PARTE\]

\[INSERIRE QUALCHE MISURAZIONE DEL CODICE, UTILIZZANDO QUALCHE METRICA CHE E' STATA VISTA A LEZIONE\]

Nel codice della nostra webapp sono stati utilizzati i seguenti design pattern:

- DAO (Data Access Object) Design Pattern
- Abstraction-Occurrence Pattern

#### DAO Design Pattern

Tale design pattern è ottimo per organizzare il codice per gestire la comunicazione tra la webapp e il database.
In questo modo, la comunicazione avviene tipo-safe, si tiene il codice pulito e si mantiene separata la logica dell'interazione con i dati dal resto del progetto.

<img width="460" height="276" alt="image" src="https://github.com/user-attachments/assets/49183a9b-3ab0-4a1b-8f43-ab5836798632" />

I file che usano questo design pattern sono i seguenti (presenti all'interno del progetto AccessiBG_Backend):

- DistributoreDAO.java;
- EdificioDAO.java;
- PianoDAO.java;
- SedeDAO.java;
- PuntoDiIngressoDAO.java;
- OstacoloDAO.java;
- ParcheggioDAO.java;
- StanzaDAO.java.

#### Abstraction-Occurrence Pattern

E' stato utilizzato tale design pattern per alcune classi perché gruppi di istanze condividevano delle stesse informazioni, perché se no sarebbe stato presente il problema della duplicazione dei dati.
Questo design pattern si basa sulla creazione di una classe astratta (classe padre) a cui sarà associato da un'altra classe (classe figlia), e gli attributi che saranno uguali per tutte le istanze della classe figlia saranno attributi della classe padre. In questa maniera, tali istanze accederanno agli stessi dati di un'unica classe astratta, evitando in questa maniera la duplicazione inutile di dati.

Esempio grafico:
<img width="663" height="478" alt="image" src="https://github.com/user-attachments/assets/fa525583-6822-41c2-bb14-e2fd9e3e5f6d" />

Le classi astratte di cui abbiamo trattato sono le seguenti (presenti nel progetto AccessiBG_Backend):

- DAO.java;
  

