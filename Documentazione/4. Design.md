## Organizzazione della documentazione



### Modelling (Lucidi nel Moodle)



DEVE contenere i diagrammi UML visti a lezione, se non già presentati in altre sezioni della

documentazione:

- use case diagram (si consiglia di metterlo nella sezione dei requisiti);

- class diagram (dal quale si DEVE generare una prima versione del codice in Java usando Papyrus Designer - si consiglia di metterlo nella sezione software design);

- ALMENO UNO state machine diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono uno state diagram come visto a lezione);

- ALMENO UN sequence diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono un sequence diagram come visto a lezione);

- UN diagramma TRA communication diagram e timing diagram;

- ALMENO UN activity diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono un activity diagram come visto a lezione);

- component diagram (si consiglia di metterlo nella sezione in cui si presenta la software architecture);

- package diagram (si consiglia di metterlo nella sezione in cui si presenta la software architecture o insieme al class diagram).



### Software Architecture (Cap.11)



* DEVE contenere la descrizione dell’architettura con almeno un paio di architectural views (per differenti punti di vista);
* DOVREBBE avere almeno una vista con connettori e componenti con la descrizione dello stile architetturale (11.4);
* DEVE utilizzare almeno una libreria esterna con maven. Ad esempio l’uso di log4j è molto consigliata.



### Software Design pattern (Cap.12)



* DEVE contenere una descrizione del design (mediante i diagrammi UML va bene);
* POTREBBE contenere un calcolo di complessità (ad esempio con McCabe) di una piccola parte;
* DOVREBBE contenere qualche misurazione del codice, (con qualche metrica che abbiamo visto). Alcuni tools che vedremo a lezione: stanide, jdepend, struture101, sonarlint, PMD…
* DEVE applicare un paio di design pattern visti a lezione;
* *Documentazione*: Documentare l’architettura e il design in documento.



---

# Introduzione

In questa documentazione verranno mostrati dei diagrammi UML riguardanti al nostro progetto.

Inoltre, si discuterà riguardo a:
- L'architettura del software, assieme alle architectural views, vista con connettori e componenti e delle librerie utilizzate;
- Il design, assieme ad un calcolo di complessità, misurazione del codice (e con quali strumenti) e i design pattern applicati.

# Modelling

### Use Case Diagram



### Class Diagram



### State Machine Diagram



### Sequence Diagram

<img width="614" height="2229" alt="image" src="https://github.com/user-attachments/assets/e1aa89f3-f645-4692-b30a-80bfe80a6735" />


### Communication Diagram



### Activity Diagram

<img width="2017" height="892" alt="Activity Diagram" src="https://github.com/user-attachments/assets/bb54e978-45fc-4d5c-a900-be0d80180909" />

### Component Diagram

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/b50cb8b0-c879-4b81-a422-7a0cc4da63ae" />


### Package Diagram





# Software Architecture

Struttura della webapp:
- **Maven**: gestione del progetto e strumento di automazione della compilazione, per i progetti Java. Utilizza POM (Project Object Model) per centralizzare e gestire in modo efficiente il processo di compilazione, la reportistica e la documentazione di un progetto;
- **Vaadin**: framework che permette di sviluppare una webapp (sia l'UI che il backend) con l'utilizzo di Java, senza l'uso di HTML e JavaScript. Inoltre, offre dei componenti già costruiti (ad esempio, griglie, form e bottoni);
- **SQLite**: motore di database embedded SQL, senza l'uso di server e senza configurazione. Legge e scrive direttamente su normali file su disco. Comunica con il progetto Maven.

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/b17a8777-5c81-4a7f-82d0-20858400cf6f" />


### Viste architettoniche

Ecco alcuni punti di vista architetturali:

#### - Punto di vista logico

Il sistema è progettato principalmente da questi elementi:

- Interfaccia della webapp;
- Backend della webapp;
- Database (SQLite, Jooq e Firebase).

Per l'interazione tra gli elemento del sistema è possibile vedere nei diagrammi sottostanti:

\[INSERIRE CLASS DIAGRAM\]

\[INSERIRE STATE MACHINE DIAGRAM\]

#### - Punto di vista dell'implementazione

Organizzazione delle classi basata su package, così per ciascun progetto.

I seguenti progetti sono strutturati in questa maniera con i package:

- Progetto Vaadin (accessibilita-unibg):
  - Applicazione per avviare la webapp + inizializzatore del DB (it.unibg.accessibilita);
  - Views (it.unibg.accessibilita.base.ui);
  - Componenti (it.unibg.accessibilita.ui.component).
 
- Progetto backend (AccessiBG_Backend):
  - Classi con design pattern DAO (dao);
  - Servizi offerti dalle università (servizi);
  - Parti della struttura universitaria (struttura).
 
- Progetto SQLite (AccessiBG_sqlite):
  - Classi per gestione DB (gestione_db).

\[INSERIRE PACKAGE DIAGRAMN\]

\[INSERIRE ALMENO UNA VISTA CON CONNETTORI E COMPONENTI CON LA DESCRIZIONE DELLO STILE ARCHITETTURALE\]

\[PARLARE ALMENO DI UNA LIBRERIA ESTERNA CON MAVEN\]



# Software Design pattern

Nel codice della nostra webapp sono stati utilizzati i seguenti design pattern:

- DAO (Data Access Object) Design Pattern
- Abstraction-Occurrence Pattern

#### DAO Design Pattern

Tale design pattern è ottimo per organizzare il codice per gestire la comunicazione tra la webapp e il database.
In questo modo, la comunicazione avviene nel mentre si tiene il codice pulito e si mantiene separata la logica dell'interazione con i dati dal resto del progetto.

<img width="460" height="276" alt="image" src="https://github.com/user-attachments/assets/49183a9b-3ab0-4a1b-8f43-ab5836798632" />

I file che usano questo design pattern sono i seguenti (presenti all'interno del progetto AccessiBG_Backend):

- DistributoreDAO.java;
- EdificioDAO.java;
- PianoDAO.java;
- SedeDAO.java.

#### Abstraction-Occurrence Pattern

E' stato utilizzato tale design pattern per alcune classi perché gruppi di istanze condividevano delle stesse informazioni, perché se no sarebbe stato presente il problema della duplicazione dei dati.
Questo design pattern si basa sulla creazione di una classe astratta (classe padre) a cui sarà associato da un'altra classe (classe figlia), e gli attributi che saranno uguali per tutte le istanze della classe figlia saranno attributi della classe padre. In questa maniera, tali istanze accederanno agli stessi dati di un'unica classe astratta, evitando in questa maniera la duplicazione inutile di dati.

Esempio grafico:
<img width="663" height="478" alt="image" src="https://github.com/user-attachments/assets/fa525583-6822-41c2-bb14-e2fd9e3e5f6d" />

Le classi astratte di cui abbiamo trattato sono le seguenti (presenti nel progetto AccessiBG_Backend):

- Stanza.java;
- ServizioSede.java.

