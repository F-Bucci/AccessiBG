## Organizzazione della documentazione



### Modelling (Lucidi nel Moodle)



DEVE contenere i diagrammi UML visti a lezione, se non già presentati in altre sezioni della

documentazione:

- use case diagram (si consiglia di metterlo nella sezione dei requisiti);

- class diagram (dal quale si DEVE generare una prima versione del codice in Java usando Papyrus Designer - si consiglia di metterlo nella sezione software design);

- ALMENO UNO state machine diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono uno state diagram come visto a lezione);

- ALMENO UN sequence diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono un sequence diagram come visto a lezione);

- UN diagramma TRA communication diagram e timing diagram;

- ALMENO UN activity diagram (NON DEVE essere troppo semplice, si deve cercare di usare la maggior parte degli elementi che costituiscono un activity diagram come visto a lezione);

- component diagram (si consiglia di metterlo nella sezione in cui si presenta la software architecture);

- package diagram (si consiglia di metterlo nella sezione in cui si presenta la software architecture o insieme al class diagram).



### Software Architecture (Cap.11)



* DEVE contenere la descrizione dell’architettura con almeno un paio di architectural views (per differenti punti di vista);
* DOVREBBE avere almeno una vista con connettori e componenti con la descrizione dello stile architetturale (11.4);
* DEVE utilizzare almeno una libreria esterna con maven. Ad esempio l’uso di log4j è molto consigliata.



### Software Design pattern (Cap.12)



* DEVE contenere una descrizione del design (mediante i diagrammi UML va bene);
* POTREBBE contenere un calcolo di complessità (ad esempio con McCabe) di una piccola parte;
* DOVREBBE contenere qualche misurazione del codice, (con qualche metrica che abbiamo visto). Alcuni tools che vedremo a lezione: stanide, jdepend, struture101, sonarlint, PMD…
* DEVE applicare un paio di design pattern visti a lezione;
* *Documentazione*: Documentare l’architettura e il design in documento.



---

# Introduzione

In questa documentazione verranno mostrati dei diagrammi UML riguardanti al nostro progetto.

Inoltre, si discuterà riguardo a:
- L'architettura del software, assieme alle architectural views, vista con connettori e componenti e delle librerie utilizzate;
- Il design, assieme ad un calcolo di complessità, misurazione del codice (e con quali strumenti) e i design pattern applicati.

# Modelling

### Use Case Diagram

<img width="913" height="1159" alt="image" src="https://github.com/user-attachments/assets/9506db1a-71ba-4e2e-98df-d32e870eb9dc" />


### Class Diagram e Package Diagram

<img width="4540" height="1780" alt="AccessiBG_ClassDiagram" src="https://github.com/user-attachments/assets/e3c79e37-6fbb-4876-b3b5-9a4699f10174" />


### State Machine Diagram

<img width="3153" height="779" alt="image" src="https://github.com/user-attachments/assets/2ae5a335-0f06-438e-b974-ab5034200a76" />


### Sequence Diagram

<img width="538" height="1451" alt="image" src="https://github.com/user-attachments/assets/51017946-5e83-409d-b83b-3a115e014e71" />


### Communication Diagram

<img width="1253" height="395" alt="image" src="https://github.com/user-attachments/assets/9a959a9b-66cb-49ca-9e9f-91bb4af4f7a5" />


### Activity Diagram

<img width="2117" height="960" alt="Activity Diagram" src="https://github.com/user-attachments/assets/5203c95a-94d3-4f8e-b961-da120ea61af7" />


### Component Diagram

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/7cd8ceac-ff5d-4d21-bf15-0bbded94c32a" />






# Software Architecture

Struttura della webapp:
- **Maven**: gestione del progetto e strumento di automazione della compilazione, per i progetti Java. Utilizza POM (Project Object Model) per centralizzare e gestire in modo efficiente il processo di compilazione, la reportistica e la documentazione di un progetto;
- **Vaadin**: framework che permette di sviluppare una webapp (sia l'UI che il backend) con l'utilizzo di Java, senza l'uso di HTML e JavaScript. Inoltre, offre dei componenti già costruiti (ad esempio, griglie, form e bottoni);
- **SQLite**: motore di database embedded SQL, senza l'uso di server e senza configurazione. Legge e scrive direttamente su normali file su disco. Comunica con il progetto Maven.

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/b9991d6c-7e82-426e-ab0d-512c0dfd19bf" />



### Viste architettoniche

Ecco alcuni punti di vista architetturali:

#### - Punto di vista logico

Il sistema è progettato principalmente da questi elementi:

- Interfaccia della webapp;
- Backend della webapp;
- Database (SQLite e Jooq).

Per l'interazione tra gli elemento del sistema è possibile vedere nei diagrammi sottostanti:

<img width="4540" height="1780" alt="AccessiBG_ClassDiagram" src="https://github.com/user-attachments/assets/e3c79e37-6fbb-4876-b3b5-9a4699f10174" />

<img width="3153" height="779" alt="image" src="https://github.com/user-attachments/assets/2ae5a335-0f06-438e-b974-ab5034200a76" />

#### - Punto di vista dell'implementazione

Organizzazione delle classi basata su package, così per ciascun progetto.

I seguenti progetti sono strutturati in questa maniera con i package:

- Progetto Vaadin (accessibilita-unibg):
  - Applicazione per avviare la webapp + inizializzatore del DB (it.unibg.accessibilita);
  - Views (it.unibg.accessibilita.base.ui);
  - Componenti (it.unibg.accessibilita.ui.component).
 
- Progetto backend (AccessiBG_Backend):
  - Classi con design pattern DAO (dao);
  - Servizi offerti dalle università (servizi);
  - Parti della struttura universitaria (struttura).
 
- Progetto SQLite (AccessiBG_sqlite):
  - Classi per gestione DB (gestione_db).

<img width="4540" height="1780" alt="AccessiBG_ClassDiagram" src="https://github.com/user-attachments/assets/e3c79e37-6fbb-4876-b3b5-9a4699f10174" />

#### Architettura e componenti e connettori

Stile architetturale: layered client-server (a strati).
L'app è organizzata in tre livelli:
- Strato del frontend: modulo accessibilita-unibg con UI costruita usando Vaadin (componenti, routing e views);
- Strato del backend: modulo AccessiBG_Backend con servizi, logica di business e accesso ai repository;
- Strato dei dati: modulo AccessiBG_sqlite con utilità di inizializzazione del database SQLite (creazione tabelle e popolamento iniziale).

<img width="560" height="347" alt="image" src="https://github.com/user-attachments/assets/b50cb8b0-c879-4b81-a422-7a0cc4da63ae" />

Componenti:
- Vaadin UI (accessibilita-unibg): view e componenti per l’interazione utente; riceve i DAO tramite dependency injection e invoca i servizi/DAO in‑process.
- Servizi (AccessiBG_Backend): espongono i metodi di servizio utilizzate dalla UI;
- Gestione DB (AccessiBG_sqlite): creazione delle table e popolazione del database (CreateTable e InsertInDB), offre il servizio di creazione del DB (CreateDB).

Connettori:
Chiamate di metodo "in-process" ("in corso"): UI e backend vengono eseguiti nello stesso processo (Spring Boot + Vaadin). Le views ricevono i DAO/servizi tramite dependency injection e chiamano direttamente i loro metodi;
- JDBC (via sqlite-jdbc): jOOQ costruisce le query tramite DSLContext e le esegue utilizzando il driver JDBC org.xerial:sqlite-jdbc. Quindi la comunicazione con il DB SQLite avviene a livello JDBC.

Librerie esterne con Maven:
- Vaadin (com.vaadin:vaadin) per la realizzazione dell'interfaccia utente e dei componenti web con l'utilizzo di Java;
- sqlite-jdbc (org.xerial:sqlite-jdbc) per l'accesso al database SQLite in modalità embedded;
- jOOQ (org.jooq:jooq e jooq-codegen) per generazione e accesso tipo-safe alle query SQL, inoltre la generazione del codice del modello DB;


# Software Design pattern

\[INSERIRE DESCRIZIONE DEL DESIGN (MEDIANTE I DIAGRAMMI UML VA BENE)\]

# **Analisi delle metriche del progetto**

Per effettuare l'analisi delle seguente metriche e' stato utilizzato STAN4J.

# **Composition graph**

![graphics](https://github.com/user-attachments/assets/e47c13f6-3ebc-4a01-9383-3a2ec1f1eedb)

Dal grafico si evidenzia una struttura gerarchica (layered):
- Il livello UI conosce i livelli sottostanti, mentre nessuno dipende da lui;
- il livello data conosce il model, ma non conosce nulla del livello UI. In questo modo in caso sia necessario un cambiamento grafico, questo livello non verra' toccato;
- il livello model non conosce nessuno, tutti dipendono da questo livello, considerato le fondamenta del progetto, quindi si evidenzia che è il livello piu' stabile e riutilizzabile.

Inoltre non è presente nel grafico, il tangle tra packages, ovvero i cicli tra packages. Quindi, per esempio, delle modifiche al livello UI non creeranno mai problemi sia al livello model che al data. L'impatto delle modifiche si ha solo verso l'alto.

# **Valori delle metriche**

<img width="760" height="546" alt="metriche" src="https://github.com/user-attachments/assets/4bd13cbd-a24a-49ff-b024-fc17cb169738" />

# **Complessità**

La complessità totale del nostro programma è pari a: 1.67.
Questo è un ottimo valore siccome denota che sono state usate poche istruzioni condizionali come if, else o for.
Il risultato sottolinea un'alta leggibilità del codice, facilità nella manutenzione e nel testing.

# **Instabilità**

L'instabilità misura il rapporto tra quanti pacchetti dipendono da un pacchetto X ($C_a$), e il totale dei pacchetti da cui un pacchetto X dipende ($C_e$).

L'Instabilità è calcolabile attraverso la formula: I= $C_e$ / ($C_a$)+($C_e$)
I= 0 --> il pacchetto è totalmente concreto.
I= 1 --> il pacchetto è totalmente astratto.

|**Pacchetto**|**Valore $C_e$**|**Valore $C_a$**|**Valore I**|
|-|-|-|-|
|`struttura` |  0 | 1 | I = 0. Completamente concreto, coerente logicamente, e la fondamenta del preogramma|
|`.accessibilita'` | 1| 0 | I=1 Completamente instabile|
|`.ui.component` | 7 | 5 | I = 0.58 Dipendono da classi in `struttura` e vengono utilizzati dal pacchetto `.ui.views`, ci si aspetta un valore simile |
|`.ui.views` | 23 | 0 | I = 1 È giusto logicamente che nessuno dipendi dalle views|
|`dao`| 12 | 5 | I = 0.71 Coerente logicamente col funzionamento del programma|
|`gestione_db` | 21 | 1 | I=0.95 Coerente siccome soltato la classe astratta DAO lo chiama | 

# **Metriche orientate agli oggetti**

# **DIT**

<img width="412" height="415" alt="image" src="https://github.com/user-attachments/assets/732be5ef-f4f9-4849-84ec-ba676f969807" />

Il grafico posiziona il progetto su un valore di DIT pari al 1.18 che conferma un'architettura senza catene di ereditarietà profonde.

# **WMC**

<img width="403" height="408" alt="image" src="https://github.com/user-attachments/assets/754207a3-1158-4b00-9a75-9965dbb379ea" />

Il valore del WMC (Weighted Methods per Class) totale è pari a: 7.64. Questo valore suggerisce che le classi hanno resposabilità limitata e definita.
Dal grafico possiamo vedere la distribuzione dei valori: circa il 70% delle classi si trova sulla colonna del 10, circa il 25% sulla colonna del 20 e circa il 5% sulla colonna del 30.

# **NOC**

<img width="411" height="412" alt="image" src="https://github.com/user-attachments/assets/a625095e-9ca4-4618-8a82-08d751416450" />

NOC (Number Of Children) ha un valore di 0.2, questo vuol dire che su 5 classi solo una classe ha un figlio. Questo si traduce in maggior facilità nel modificare le classi, siccome è improbabile che modificandone una se ne rompa un'altra.

# **CBO**

<img width="412" height="411" alt="image" src="https://github.com/user-attachments/assets/d65f0622-3b24-4995-9da6-8abc8181fb14" />

CBO (Coupling Between Objects) è pari al 1.73 calcolato in base al numero di classi collegate a una classe. Questo valore denota una alta coesione e un basso accoppiamento.

# **LCOM**

<img width="415" height="410" alt="image" src="https://github.com/user-attachments/assets/bd14e950-beb9-4583-b973-2e719edf545c" />

LCOM (Lack Of Cohesion in Methods) mostra un valore uguale a 7.64. Analizzando il grafico possiamo dedurre che le classi che alzano la media (quelle sulla destra) sono le classi del Model con molti metodi `Getter` che vengono interpetrati come poco coesi da STAN4J.

# **RFC**

<img width="414" height="413" alt="image" src="https://github.com/user-attachments/assets/e4526660-3c1f-4937-b3b7-78d6af0701f9" />

RDC (Response For a Class) ha un valore pari a 8.38 che indicano classi altamente coese e poco accoppiate e dimostra che quando una classe viene utilizzata invocano pochissime procedure esterne.

# **DESIGN PATTERN**

Nel codice della nostra webapp sono stati utilizzati i seguenti design pattern:

- DAO (Data Access Object) Design Pattern
- Abstraction-Occurrence Pattern

#### DAO Design Pattern

Tale design pattern è ottimo per organizzare il codice per gestire la comunicazione tra la webapp e il database.
In questo modo, la comunicazione avviene tipo-safe, si tiene il codice pulito e si mantiene separata la logica dell'interazione con i dati dal resto del progetto.

<img width="460" height="276" alt="image" src="https://github.com/user-attachments/assets/49183a9b-3ab0-4a1b-8f43-ab5836798632" />

I file che usano questo design pattern sono i seguenti (presenti all'interno del progetto AccessiBG_Backend):

- DistributoreDAO.java;
- EdificioDAO.java;
- PianoDAO.java;
- SedeDAO.java;
- PuntoDiIngressoDAO.java;
- OstacoloDAO.java;
- ParcheggioDAO.java;
- StanzaDAO.java.

#### Composite (General Hierarchy Pattern)

Nel Frontend con Vaadin viene utilizzato il Composite Pattern. Le classi dei componenti formano una gerarchia nell'interfaccia utente.
Il componente e' un oggetto generale, infatti nel codice Vaadin tutto e' un "componente". Il container e' un oggetto SuperiorNode che puo' contenere altri oggetti (VerticalLayout contiene EdificiView per esempio), mentere gli altri componenti come `ImageCard` `SelettorePiano` e `Box` sono NonSuperiorNodes e sono oggetti che non contengono nulla.

<img width="695" height="420" alt="image" src="https://github.com/user-attachments/assets/b174cb14-85dd-461e-a825-6775f6b358a1" />

<img width="936" height="509" alt="image" src="https://github.com/user-attachments/assets/2b758028-9f76-4531-8604-01f3eec3e922" />


